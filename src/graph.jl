using JSON
using SparseArrays
using LightGraphs
abstract type AbstractGraph end

struct Graph<:AbstractGraph
    num_nodes::Int
    num_edges::Int
    num_dists::Int
    total_pop::Int
    populations::Array{Int, 1}             # of length(num_nodes)
    adj_matrix::SparseMatrixCSC{Int, Int}
    edge_src::Array{Int, 1}                # of length(num_edges)
    edge_dst::Array{Int, 1}                # of length(num_edges)
    neighbors::Array{Array{Int64,1},1}
    simple_graph::SimpleGraph              # the base SimpleGraph, if we need it
    attributes::Array{Dict{String, Any}}
end

function Graph(filepath::AbstractString,
               pop_col::AbstractString,
               assignment_col::AbstractString,
               nodes_str::AbstractString = "nodes",
               adjacency_str::AbstractString = "adjacency",
               edge_id_str::AbstractString = "id")::Graph

    """ Builds the base Graph object. This is the underlying network of our
        districts, and its properties are immutable i.e they will not change
        from step to step in out Markov Chains.

        Arguments:
            filepath: file path to the .json file that contains the graph. This
                      file is expected to be generated by the `Graph.to_json()`
                      function of the Python implementation of Gerrychain. [1]

        [1]: https://github.com/mggg/GerryChain/blob/c87da7e69967880abc99b781cd37468b8cb18815/gerrychain/graph/graph.py#L38
    """
    raw_graph = JSON.parsefile(filepath)
    num_nodes = length(raw_graph[nodes_str])

    # get populations, assignments and num_districts
    populations, assignments = get_populations_and_assignments(raw_graph, pop_col, assignment_col,
                                                               num_nodes, nodes_str)
    num_districts = length(Set(assignments))
    total_pop = sum(populations)

    # Generate the base SimpleGraph.
    simple_graph = SimpleGraph(num_nodes)
    for (index, edges) in enumerate(raw_graph[adjacency_str])
        for edge in edges
            if edge[edge_id_str] + 1 > index
                add_edge!(simple_graph, index, edge[edge_id_str] + 1)
            end
        end
    end

    num_edges = ne(simple_graph)

    # edge `i` would connect nodes edge_src[i] and edge_dst[i]
    edge_src = zeros(Int, num_edges)
    edge_dst = zeros(Int, num_edges)
    neighbors = [Int[] for i in 1:num_nodes, j=1]

    # each entry in adj_matrix is the edge id that connects the two nodes.
    adj_matrix = spzeros(Int, num_nodes, num_nodes)
    for (index, edge) in enumerate(edges(simple_graph))
        adj_matrix[src(edge), dst(edge)] = index
        adj_matrix[dst(edge), src(edge)] = index

        edge_src[index] = src(edge)
        edge_dst[index] = dst(edge)

        push!(neighbors[src(edge)], dst(edge))
        push!(neighbors[dst(edge)], src(edge))
    end

    # get attributes
    attributes = get_attributes(raw_graph, num_nodes, nodes_str)

    return Graph(num_nodes, num_edges, num_districts, total_pop, populations,
                 adj_matrix, edge_src, edge_dst, neighbors, simple_graph, attributes)
end


function get_attributes(raw_graph::Dict{String, Any},
                        num_nodes::Int,
                        nodes_str::AbstractString = "nodes")
    """ Returns an array of dicts where the attributes of the i'th node is
        at attributes[i] as a dictionary.
    """
    attributes = Array{Dict{String, Any}}(undef, num_nodes)
    for (index, node) in enumerate(raw_graph["nodes"])
        attributes[index] = node
    end
    return attributes
end
